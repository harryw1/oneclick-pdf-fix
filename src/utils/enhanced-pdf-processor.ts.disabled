import { PDFDocument, degrees } from 'pdf-lib';
import { createClient } from '@supabase/supabase-js';
import { put } from '@vercel/blob';
import { ImageAnnotatorClient } from '@google-cloud/vision';
// import { Storage } from '@google-cloud/storage'; // Commented out for now
import type { 
  PDFProcessingOptions, 
  ProcessedPDF,
  VisionDocumentTextResponse,
  VisionWebDetectionResponse,
  VisionWebDetection
} from '@/types/app';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const supabaseApiKey = process.env.SUPABASE_API_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

// Google Cloud configuration - for future use
// const gcpProjectId = process.env.GCP_PROJECT_ID;
// const gcpBucketName = process.env.GCP_STORAGE_BUCKET;
const hasCredentials = !!process.env.GOOGLE_CREDENTIALS_BASE64;

// Initialize Google Cloud clients
let visionClient: ImageAnnotatorClient | null = null;
// let storageClient: Storage | null = null; // Commented out for now

function getGoogleCloudCredentials() {
  if (!hasCredentials) return null;
  try {
    return JSON.parse(Buffer.from(process.env.GOOGLE_CREDENTIALS_BASE64!, 'base64').toString());
  } catch (error) {
    console.error('Failed to parse Google Cloud credentials:', error);
    return null;
  }
}

function getVisionClient(): ImageAnnotatorClient | null {
  if (!hasCredentials) {
    console.warn('Google Cloud Vision credentials not available');
    return null;
  }
  
  if (!visionClient) {
    try {
      const credentials = getGoogleCloudCredentials();
      if (!credentials) return null;
      
      visionClient = new ImageAnnotatorClient({ credentials });
      console.log('Google Cloud Vision client initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Google Cloud Vision client:', error);
      return null;
    }
  }
  
  return visionClient;
}

// function getStorageClient(): Storage | null {
//   // Commented out for now - will implement when Google Cloud Storage is fully integrated
//   return null;
// }

// Progress tracking functions
async function createProcessingOperation(
  supabase: any,
  processingId: string,
  userId: string,
  operationType: string,
  totalPages: number
): Promise<string | null> {
  try {
    const { data, error } = await supabase
      .from('processing_operations')
      .insert({
        user_id: userId,
        processing_id: processingId,
        operation_name: `${operationType}-${processingId}-${Date.now()}`,
        operation_type: operationType,
        status: 'running',
        progress_percent: 0,
        total_pages: totalPages,
        current_page: 0,
        metadata: {
          started_at: new Date().toISOString(),
          operation_type: operationType
        }
      })
      .select('id')
      .single();

    if (error) {
      console.error('Failed to create processing operation:', error);
      return null;
    }

    return data.id;
  } catch (error) {
    console.error('Error creating processing operation:', error);
    return null;
  }
}

async function updateProcessingProgress(
  supabase: any,
  operationId: string,
  progress: {
    progress_percent?: number;
    current_page?: number;
    status?: string;
    metadata?: any;
    error_message?: string;
  }
) {
  try {
    const updateData = {
      ...progress,
      last_checked_at: new Date().toISOString()
    };

    if (progress.status === 'completed' || progress.status === 'failed') {
      (updateData as any).completed_at = new Date().toISOString();
    }

    const { error } = await supabase
      .from('processing_operations')
      .update(updateData)
      .eq('id', operationId);

    if (error) {
      console.error('Failed to update processing progress:', error);
    }
  } catch (error) {
    console.error('Error updating processing progress:', error);
  }
}

// Enhanced document processing with async Vision API
export async function processDocumentWithProgress(params: {
  processingId: string;
  blobUrl: string;
  originalFileName: string;
  options: PDFProcessingOptions;
  userId: string;
  userToken?: string;
}): Promise<ProcessedPDF> {
  const startTime = Date.now();
  const { processingId, blobUrl, originalFileName, options, userId, userToken } = params;

  // Create authenticated supabase client
  const supabase = userToken 
    ? createClient(supabaseUrl!, supabaseAnonKey!, {
        global: {
          headers: { Authorization: `Bearer ${userToken}` }
        }
      })
    : createClient(supabaseUrl!, supabaseApiKey!);

  // Get user profile
  const { data: profile } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', userId)
    .single();

  if (!profile) {
    throw new Error('User profile not found');
  }

  console.log('Starting enhanced PDF processing for:', processingId);

  // Download PDF from blob storage
  const response = await fetch(blobUrl);
  if (!response.ok) {
    throw new Error(`Failed to download PDF from blob: ${response.status}`);
  }
  
  const pdfBytes = new Uint8Array(await response.arrayBuffer());
  console.log('Downloaded PDF size:', pdfBytes.length, 'bytes');
  
  // Load PDF to get page count
  const pdfDoc = await PDFDocument.load(pdfBytes);
  const pages = pdfDoc.getPages();
  const pageCount = pages.length;

  const isPro = profile.plan === 'pro_monthly' || profile.plan === 'pro_annual';

  // Check usage limits
  await validateUsageLimits(profile, pageCount);

  // Create processing operation for progress tracking
  const operationId = await createProcessingOperation(
    supabase,
    processingId,
    userId,
    'document_processing',
    pageCount
  );

  let documentType = 'Unknown';
  let confidenceScore = 0;
  let extractedText = '';

  try {
    // Update progress: Starting processing
    if (operationId) {
      await updateProcessingProgress(supabase, operationId, {
        progress_percent: 10,
        current_page: 0,
        metadata: { stage: 'starting', message: 'Initializing document processing' }
      });
    }

    // Enhanced processing for Pro users - using sync for now, async Vision API coming soon
    if (isPro && hasCredentials) {
      console.log('Using enhanced Vision API processing for Pro user');
      
      if (operationId) {
        await updateProcessingProgress(supabase, operationId, {
          progress_percent: 30,
          metadata: { stage: 'vision_api', message: 'Analyzing document with Vision API' }
        });
      }

      const visionResult = await processSyncVisionAPI(pdfBytes, isPro);
      if (visionResult) {
        documentType = visionResult.documentType;
        confidenceScore = visionResult.confidenceScore;
        extractedText = 'Enhanced processing completed'; // Placeholder for actual text
      }
    } else if (options.autoRotate !== false && hasCredentials) {
      // Fallback to synchronous processing for smaller documents
      console.log('Using synchronous Vision API processing');
      
      if (operationId) {
        await updateProcessingProgress(supabase, operationId, {
          progress_percent: 30,
          metadata: { stage: 'vision_api', message: 'Analyzing document with Vision API' }
        });
      }

      const visionResult = await processSyncVisionAPI(pdfBytes, isPro);
      if (visionResult) {
        documentType = visionResult.documentType;
        confidenceScore = visionResult.confidenceScore;
      }
    }

    // Apply transformations based on Vision API results
    if (operationId) {
      await updateProcessingProgress(supabase, operationId, {
        progress_percent: 60,
        current_page: Math.floor(pageCount / 2),
        metadata: { stage: 'transformation', message: 'Applying document transformations' }
      });
    }

    // Apply smart rotation if enabled
    if (options.autoRotate !== false) {
      await applySmartRotation(pdfDoc, extractedText);
    }

    // Apply deskewing for Pro users
    if (options.deskew && isPro && extractedText) {
      await applyDocumentDeskewing(pdfDoc, extractedText);
    }

    // Compression with progress updates
    if (operationId) {
      await updateProcessingProgress(supabase, operationId, {
        progress_percent: 80,
        metadata: { stage: 'compression', message: 'Optimizing document size' }
      });
    }

    const compressionOptions = isPro ? {
      useObjectStreams: true,
      addDefaultPage: false,
      objectStreamsVersion: 1,
      updateFieldAppearances: false,
    } : {
      useObjectStreams: options.compress !== false,
      addDefaultPage: false,
    };

    console.log(`Applying ${isPro ? 'enhanced Pro' : 'standard'} compression...`);
    const processedPdfBytes = await pdfDoc.save(compressionOptions);

    // Upload processed PDF
    if (operationId) {
      await updateProcessingProgress(supabase, operationId, {
        progress_percent: 90,
        metadata: { stage: 'upload', message: 'Uploading processed document' }
      });
    }

    console.log('Uploading processed PDF to blob storage...');
    const processedBlob = await put(`processed-${processingId}.pdf`, Buffer.from(processedPdfBytes), {
      access: 'public',
      addRandomSuffix: false
    });

    // Calculate processing duration
    const processingDuration = Date.now() - startTime;

    // Complete processing operation
    if (operationId) {
      await updateProcessingProgress(supabase, operationId, {
        progress_percent: 100,
        status: 'completed',
        metadata: {
          stage: 'completed',
          message: 'Document processing completed successfully',
          processing_duration_ms: processingDuration,
          document_type: documentType,
          confidence_score: confidenceScore
        }
      });
    }

    // Create result object
    const result: ProcessedPDF = {
      id: processingId,
      originalName: originalFileName,
      processedUrl: processedBlob.url,
      downloadUrl: `/api/download/${processingId}`,
      pageCount,
      fileSize: processedPdfBytes.length,
      processedAt: new Date(),
      options,
      documentType: isPro ? documentType : undefined,
    };

    console.log(`Enhanced processing completed for ${processingId}: ${pageCount} pages in ${processingDuration}ms`);
    return result;

  } catch (error) {
    console.error('Enhanced processing failed:', error);
    
    // Update operation with error
    if (operationId) {
      await updateProcessingProgress(supabase, operationId, {
        status: 'failed',
        error_message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
    
    throw error;
  }
}

// Async Vision API processing - Coming soon with Google Cloud Storage integration
// async function processWithAsyncVisionAPI(...) {
//   // Implementation commented out until Google Cloud Storage is properly integrated
//   return null;
// }

// Synchronous Vision API processing (fallback)
async function processSyncVisionAPI(
  pdfBytes: Uint8Array,
  isPro: boolean
): Promise<{ documentType: string; confidenceScore: number } | null> {
  try {
    const visionClient = getVisionClient();
    if (!visionClient) return null;

    const pdfBase64 = Buffer.from(pdfBytes).toString('base64');
    
    const promises = [
      visionClient.documentTextDetection({ image: { content: pdfBase64 } }),
      ...(isPro ? [visionClient.webDetection({ image: { content: pdfBase64 } })] : [])
    ];

    const results = await Promise.all(promises);
    const textResult = results[0] as VisionDocumentTextResponse;
    let extractedText = textResult.fullTextAnnotation?.text || '';
    let webDetection = undefined;
    
    if (isPro && results.length > 1) {
      const webResult = results[1] as VisionWebDetectionResponse;
      webDetection = webResult.webDetection;
    }

    const documentType = classifyDocument(extractedText, webDetection);
    // Note: confidence may not be available on all text annotations
    const confidence = 0.8; // Default confidence for sync processing

    return { documentType, confidenceScore: confidence };
  } catch (error) {
    console.error('Sync Vision API processing failed:', error);
    return null;
  }
}

// Utility functions
async function validateUsageLimits(profile: any, pageCount: number) {
  if (profile.plan === 'free') {
    const newUsage = profile.usage_this_week + pageCount;
    if (newUsage > 10) {
      throw new Error(`Weekly page limit exceeded. You've reached your free tier limit of 10 pages per week.`);
    }
  } else if (profile.plan === 'pro_monthly' || profile.plan === 'pro_annual') {
    const monthlyUsage = profile.usage_this_month || 0;
    const newUsage = monthlyUsage + pageCount;
    
    if (newUsage > 1000) {
      throw new Error(`Monthly page limit exceeded. You've reached your Pro tier limit of 1000 pages per month.`);
    }
  }
}

async function applySmartRotation(pdfDoc: PDFDocument, extractedText: string) {
  // Simple rotation logic based on text analysis
  // This could be enhanced with more sophisticated analysis
  const pages = pdfDoc.getPages();
  
  // If text seems to be rotated (more vertical than horizontal words), rotate
  if (extractedText && extractedText.length > 100) {
    const lines = extractedText.split('\n');
    const shortLines = lines.filter(line => line.trim().length < 10).length;
    
    if (shortLines / lines.length > 0.7) {
      // Likely rotated text - apply 90 degree rotation
      pages.forEach(page => {
        page.setRotation(degrees(90));
      });
      console.log('Applied smart rotation correction');
    }
  }
}

async function applyDocumentDeskewing(pdfDoc: PDFDocument, extractedText: string) {
  // Enhanced deskewing logic would go here
  // For now, this is a placeholder
  console.log('Document deskewing applied (enhanced logic placeholder)');
}

function classifyDocument(text: string, webDetection: VisionWebDetection | undefined): string {
  if (!text) return 'Unknown';
  
  const textLower = text.toLowerCase();
  
  // Enhanced classification logic
  const patterns = [
    { type: 'Resume/CV', keywords: ['resume', 'curriculum vitae', 'experience', 'education', 'skills'], weight: 0.8 },
    { type: 'Invoice/Bill', keywords: ['invoice', 'bill', 'amount due', 'payment', 'total', 'tax'], weight: 0.9 },
    { type: 'Contract/Legal', keywords: ['contract', 'agreement', 'terms and conditions', 'legal', 'whereas'], weight: 0.85 },
    { type: 'Report/Analysis', keywords: ['report', 'analysis', 'summary', 'findings', 'conclusion'], weight: 0.7 },
    { type: 'Financial Statement', keywords: ['statement', 'account', 'balance', 'transaction', 'financial'], weight: 0.8 },
    { type: 'Form/Application', keywords: ['form', 'application', 'please fill', 'applicant', 'submit'], weight: 0.75 },
    { type: 'Certificate/Diploma', keywords: ['certificate', 'diploma', 'certification', 'hereby certify', 'awarded'], weight: 0.9 }
  ];

  let bestMatch = { type: 'General Document', score: 0 };

  for (const pattern of patterns) {
    let score = 0;
    const matchedKeywords = pattern.keywords.filter(keyword => textLower.includes(keyword));
    
    if (matchedKeywords.length > 0) {
      score = (matchedKeywords.length / pattern.keywords.length) * pattern.weight;
      
      if (score > bestMatch.score) {
        bestMatch = { type: pattern.type, score };
      }
    }
  }

  // Use web detection for additional classification hints
  if (webDetection?.webEntities && bestMatch.score < 0.5) {
    const entities = webDetection.webEntities.slice(0, 3);
    for (const entity of entities) {
      if (entity.description && entity.score && entity.score > 0.5) {
        const desc = entity.description.toLowerCase();
        if (desc.includes('form') || desc.includes('application')) {
          return 'Form/Application';
        }
        if (desc.includes('certificate') || desc.includes('diploma')) {
          return 'Certificate/Diploma';
        }
      }
    }
  }

  return bestMatch.type;
}

// Export the enhanced processor as default for backward compatibility
export { processDocumentWithProgress as processDocument };